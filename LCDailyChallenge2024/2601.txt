//https://leetcode.com/problems/out-of-boundary-paths/


/*
    3D memoization
*/
class Solution {

    int[][] direction = {
        {1, 0},
        {0, -1},
        {-1, 0},
        {0, 1}
    };

    private int func(int m, int n, int moveLeft, int r, int c, int[][][] dp) {
        if (moveLeft < 0) {
            return 0;
        }

        if (r < 0 || r >= m || c < 0 || c >= n) {
            return 1;
        }

        if (dp[r][c][moveLeft] != -1) {
            return dp[r][c][moveLeft];
        }

        long ans = 0;
        int mod = 1000000007;
        for (int i=0; i<direction.length; i++) {
            ans += (func(m, n, moveLeft-1, r+direction[i][0], c+direction[i][1], dp)) % mod;
        }        
        return dp[r][c][moveLeft] = (int) (ans % mod);
    }

    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        int[][][] dp = new int[m][n][maxMove+1];
        for (int i=0; i<dp.length; i++) {
            for (int j=0; j<dp[0].length; j++) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        return func(m, n, maxMove, startRow, startColumn, dp);
    }
}